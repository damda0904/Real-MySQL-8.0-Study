# 4. 아키텍처
## 4.1 MySQL 엔진 아키텍처

### 4.1.1 MySQL 전체 구조

MySQL 서버는 크게 **MySQL 엔진**과 **스토리지 엔진**으로 구분할 수 있다. 

#### 4.1.1.1 MySQL 엔진

구성요소는 다음과 같다

커넥션 핸들러 : 클라이언트로부터의 접속 및 쿼리 요청을 처리

SQL 파서 및 전처리기 

옵티마이저 : 쿼리의 최적화된 실행을 위한 요소



#### 4.1.1.2 스토리지 엔진

**DBMS 두뇌**에 해당하는 처리를 수행하는 엔진.

실제 데이터를 디스크 스토리지에 저장하거나, 스토리지에서 읽어오는 부분을 담당한다.



→ MySQL 엔진은 하나지만 스토리지 엔진은 여러개를 동시에 사용할 수 있다.



#### 4.1.1.3 핸들러 API

MySQL 엔진이 쿼리 실행기에서 데이터를 읽고 쓸 때 스토리지 엔진에 보내는 요청을 **핸들러 요청**이라고 한다.

여기서 사용하는 api를 핸들러 API라고 부른다.

이 핸들러 api를 통해 얼마나 많은 데이터 작업이 있는지는 `SHOW GLOBAL STATUS LIKE 'Handler%';` 로 확인할 수 있다.



#### 4.1.2 MySQL 스레딩 구조

MySQL은 프로세스 기반이 아닌 **스레드 기반**으로 작동한다.

스레드는 크게 **포그라운드(Foreground)**와 **백그라운드(Background) 스레드**로 구분할 수 있다.

실행중인 스레드 목록은 performance_schema 데이터베이스의 threads 테이블에서 확인할 수 있다.



여기서 설명되는 내용은 전통적인 스레드 모델인데, 엔터프라이즈 에디션에서는 스레드 풀(Thread Pool) 모델을 사용할 수 있는데, 전통적인 스레드 모델과의 차이점은 다음과 같다

전통적인 스레드 모델은 커넥션 - 포그라운드 스레드가 1:1로 생성된다

스레드 풀에서는 커넥션 - 포그라운드 스레드가 1:n으로 연결이 가능하다



_그래서 AWS RDB의 커넥션수를 올리려면 cpu 사양을 늘리거나 서버리스의 경우 ACU 개수를 늘려야했을까?_



#### 4.1.2.1 포그라운드 스레드(클라이언트 스레드)

포그라운드 스레드는 최소 MySQL 서버에 접속된 클라이언트 수만큼 존재한다.

클라이언트가 커넥션을 종료하면 담당 스레드는 다시 **스레드 캐시**로 돌아간다. 이때, 이미 일정 개수 이상 대기중인 스레드가 있다면 스레드는 종료된다. (최대 스레드 개수 변경 : thread_cache_size 시스템 변수 사용)


포그라운드는 데이터를 데이터 버퍼나 캐시, 혹은 직접 디스크의 데이터나 인덱스 파일에서 읽어와 작업을 처리한다



#### 4.1.2.2 백그라운드 스레드

InnoDB는 백그라운드 스레드가 다양한 작업을 처리한다

- 인서트 버퍼(Insert Buffer)를 병합
- 로그를 디스크로 기록
- InnoDB 버퍼풀의 데이터를 디스크로 기록
- 데이터를 버퍼로 읽어오기
- 잠금이나 데드락을 모니터링
- 등등..

이 중 가장 중요한 것은 쓰기 스레드로, 디스크를 최적으로 사용할 수 있을 만큼 충분히 설정하는게 중요하다.



InnoDB에서는 Insert, Update, Delete 쿼리로 데이터 변경 시 **쓰기 버퍼링 기능**이 있기 때문에 읽기 작업은 쓰기 작업을 기다리지 않고 바로 수행될 수 있다.

그러나 MyISAM은 쓰기 버퍼링 기능을 사용할 수 없다.



### 4.1.3 메모리 할당 및 사용 구조

#### 4.1.3.1 글로벌 메모리 영역

글로벌 메모리 영역은 MySQL 서버가 시작되면서 운영체제로부터 할당된다.

클라이언트 스레드 수와 무관하게 하나의 메모리 공간만 할당되며, 여러개일 경우에도 클라이언트 스레드 수와는 무관하다. 또한 **모든 스레드가 N개의 글로벌 영역을 공유**한다.

#### 4.1.3.2 로컬 메모리 영역(세션 메모리 영역, 클라이언트 메모리 영역)

클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역이다.

로컬 메모리는 클라이언트 스레드 별로 독립적으로 할당되며 절대 공유되지 않는다.

또한 쿼리 용도별로 필요할 때만 공간이 할당되고, 필요하지 않을 경우는 할당조차 하지 않는 경우도 있다. 

커넥션이 열려있는 동안 계속 할당된 상태로 남아있는 공간도 있고(커넥션 버퍼, 결과 버퍼) 쿼리를 실행하는 순간에만 할당 후 해제하는 공간(소트 버퍼, 조인 버퍼)도 있다.



### 4.1.4. 플러그인 스토리지 엔진 모델

MySQL에서 플러그인해 쓸 수 있는 것은 상당히 다양하다

- 스토리지 엔진
- 검색어 파서
- Native Authentication
- Caching SHA-2 Authentication
- 등등…

MySQL 엔진은 **핸들러**라는 것을 통해 스토리지 엔진에서 데이터 읽기/쓰기 작업을 요청하는데, 스토리지 엔진은 단순한 역할만 하고 Group By/Order By 같은 복잡한 처리는 MySQL 엔진 처리영역인 **쿼리 실행기**에서 처리된다



### 4.1.5 컴포넌트

MySQL 8.0부터는 기존 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처가 지원된다.

컴포넌트는 아래 단점들을 보완하고 있다

- 플러그인은 오직 MySQL 서버와만 인터페이스가 가능하며, 플러그인끼리는 불가능
- 플러그인은 MySQL 변수, 함수를 직접 호출하기에 안전하지 않음
- 상호 의존관계를 설정할 수 없어 초기화가 어려움


### 4.1.6 쿼리 실행 구조

#### 4.1.6.1 쿼리 파서
- 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만드는 작업을 한다
- 기본 문법 오류가 여기서 발견된다


#### 4.1.6.2 전처리기
- 파서 트리를 기반으로 쿼리 문장에 구조적 문제가 있는지 확인한다
- 해당 객체의 존재 여부와 객체 접근 권한을 확인한다.


#### 4.1.6.3 옵티마이저
- DBMS의 두뇌
- 요청으로 들어온 쿼리 문장을 저렴한 비용으로 빠르게 처리할 방법을 결정한다


#### 4.1.6.4 실행 엔진
- 옵티마이저가 두뇌라면 실행 엔진은 손, 발에 해당한다
- 옵티마이저가 만든 계획대로 각 핸들러에 요청해서 받은 결과를 또다른 핸들러 요청으로 연결하는 역할을 한다.


#### 4.1.6.5 핸들러(스토리지 엔진)
- 실행 엔진의 요청에 따라 데이터를 디스크에 저장하고, 디스크에서 읽어오는 역할을 한다.
- MyISAM, InnoDB 스토리지 엔진 등이 해당한다
> 옵티마이저 → 실행 엔진 → 핸들러(스토리지 엔진)


### 4.1.8 쿼리 캐시

쿼리 캐시는 빠른 응답을 필요로 하는 웹 응용 프로그램에서 매우 중요한 역할을 하지만, **심각한 동시 처리 성능 저하**를 유발하는 단점을 가지고 있다. 

테이블의 데이터가 변경되면 캐시 저장 결과 중 변경된 테이블 관련 내용을 모두 삭제해야했고, 동시 처리 기능 성능 저하와 많은 버그의 원인이 되었다.

따라서 8.0 버전부터는 쿼리 캐시는 **MySQL 서버 기능에서 완전히 제거**되었다.



### 4.1.9 스레드 풀

스레드풀은 사용자의 요청을 처리하는 스레드 개수를 줄여 CPU가 제한된 개수의 스레드 처리에 집중할 수 있도록 서버 자원 소모를 줄이는 것을 목적으로 한다.

- 기본적으로 CPU 코어 개수만큼 스레드 그룹을 생성하는데, thread_pool_size 시스템 변수로 그룹 개수를 조절할 수 있다. 
- `thread_pool_oversubscribe` 시스템 변수는 스레드 풀이 받아들여서 처리하는 개수를 조절할 수 있다(기본 3)
- 스레드 풀의 타이머 스레드는 주기적으로 스레드 그룹 상태를 체크해서 thread_pool_stall_limit 시스템 변수에 정의된 시간 안에 작업을 끝내지 못하면 새 스레드를 생성해서 스레드 그룹에 추가한다.
- 전체 스레드 풀에 있는 스레드 개수는 `thread_pool_max_threads`를 넘지 못한다



### 4.1.10 트랜잭션 지원 메타데이터

테이블 구조 정보와 스토어드 프로그램 등의 정보를 **데이터 딕셔너리**, 혹은 **메타데이터**라고 하는데 5.7 버전까지는 FRM 파일에 저장했다. 

그러나 파일 기반 메타데이터는 생성, 변경 작업이 트랜잭션을 지원하지 않기 때문에 비정상적으로 서버가 종료되면 일관되지 않는 상태로 남아있게 된다.

따라서 8.0 버전에서는 모두 **InnoDB의 테이블**에 저장되도록 개선되었다.

InnoDB 스토리지 엔진 이외 스토리지 엔진을 사용하는 테이블은 SDI(Serialized Dictionary Information) 파일을 사용한다. 



# 4.2 InnoDB 스토리지 엔진 아키텍처

InnoDB는 스토리지 엔진 중 유일하게 **레코드 기반 잠금**을 제공하기 때문에 높은 동시성을 지닌다.


### 4.2.1 프라이머리 키에 의한 클러스터링

- InnoDB 테이블은 모두 기본적으로 프라이머리 키를 기준을 클러스터링된다. 즉, 프라이머리 키 값 순으로 디스크에 저장된다. 
- 모든 세컨더리 인덱스는 프라이머리 키 값을 논리적 주소로 사용한다
- MyISAM 엔진은 클러스터링 키를 지원하지 않아 프라이머리 키와 세컨더리 인덱스는 구조적으로 차이가 없다.



### 4.2.2. 외래 키 지원

- InnoDB 스토리지 엔진 레벨에서 지원하는 기능이다
- InnoDB 외래키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고, 잠금이 여러 테이블로 전파된다. 따라서 데드락이 발생할 경우가 많다
- 수동으로 데이터를 적재하거나 스키마 변경을 할 경우, 이 외래키가 문제가 될 수 있다. 이때 foreign_key_checks를 OFF로 설정하면 외래키 관계 체크 작업을 일시적으로 멈출 수 있다.(단, 반드시 관계 테이블 레코드도 수정해서 관계를 유지시켜주어야 한다)



### 4.2.3 MVCC(Multi Version Concurrency Control)

- 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능
- 잠금을 사용하지 않는 일관된 읽기를 제공하는 것이 가장 큰 목적이다
- 멀티 버전 : 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 것
- 한 트랜잭션이 쓰기 작업을 수행중일 때(커밋이나 롤백이 되지 않고, 변경사항이 아직 버퍼에 남아있을 때), 읽기 작업이 들어오면 시스템 변수의 격리 수준에 따라 다른 값을 읽게 된다.
    - READ_UNCOMMITED : InnoDB 버퍼 풀에서 변경된 데이터를 읽어온다
    - READ_COMMITED, REPEATABLE_READ, SERIALIZABLE : 변경되기 이전의 내용을 보관중인 언두 영역의 데이터를 읽어온다
    → 즉, 하나의 데이터에 대해 2가지 버전(버퍼 풀, 언두 영역)을 가지고 있고, 여러 상황에 따라 읽기 결과가 달라지는 구조이다.
- COMMIT 명령을 실행하면 버퍼 풀의 데이터를 영구적인 데이터로 만들고, 롤백을 실행하면 언두 영역의 데이터를 다시 덮어쓰게 된다.



### 4.2.4 잠금 없는 일관된 읽기

- InnoDB 엔진은 MVCC 기술을 통해 잠금 없이 읽기 작업을 수행한다
- 이 읽기 작업은 트랜잭션이 잠금을 통해 작업을 수행중일 때 **변경되기 전의 데이터를 읽기 위해 언두 로그를 사용**하게 된다.
- 이러한 일관된 읽기 때문에 트랜잭션이 길어지면 언두 로그를 삭제하지 않고 적재될 가능성이 높아 가능한 빨리 커밋 혹은 롤백으로 트랜잭션을 완료해야한다



### 4.2.5 자동 데드락 감지

- InnoDB 엔진은 내부적으로 잠금이 교착상태에 빠지지 않았는지를 확인하기 위해 잠금 목록 그래프로 관리한다
- 교착상태에 빠진 트랜잭션들을 찾아, 언두 로그 양이 적은 트랜잭션을 강제 종료한다 
- innodb_table_locks 시스템 변수를 활성화하면 레코드 잠금 뿐 아니라 테이블 레벨 잠금도 감지할 수 있게 된다
- 동시 처리 스레드의 개수가 많을 경우, 데드락 감지 스레드의 속도가 느려져 CPU 자원을 많이 소모할 수 있다. 이 경우 innodb_deadlock_detect 시스템 변수를 OFF 시켜 데드락 감지 스레드를 꺼둘 수 있다.
- 데드락 감지 스레드가 꺼져있을 경우, innodb_lock_wait_timeout 시스템 변수로 데드락 상황에서 일정 시간이 지나면 자동으로 요청을 취소하도록 설정할 수 있다



### 4.2.6 자동화된 장애 복구

기본적으로 MySQL 서버가 시작될 때 항상 자동 복구를 수행하지만, 자동으로 복구할 수 없는 손상이 있을 경우 innodb_force_recovery 시스템 변수를 설정해서 MySQL 서버를 시작해야 한다

각 복구 모드에 대한 설명은 아래와 같다

- 1(SRV_FORCE_IGNORE_CORRUPT)
    - 데이터나 인덱스 페이지에서 손상된 부분이 발견된 경우 무시한다
    - `Database page corruption on disk or a failed` 메세지가 출력될 경우에 해당한다

- 2(SRV_FORCE_NO_BACKGROUND)
    - 백그라운드 스레드 중 메인 스레드를 시작하지 않고 MySQL서버를 시작한다
    - 언두 데이터를 삭제하는 과정에서 장애가 발생한 경우 이 모드를 사용한다

- 3(SRV_FORCE_NO_TRX_UNDO)
    - 커밋되지 않은 트랜잭션 작업을 롤백하지 않고 그대로 둔다

- 4(SRV_FORCE_NO_IBUF_MERGE)
    - 인서트 버퍼의 내용을 무시하고 강제로 MySQL 서버를 시작한다
    - 인서트 버퍼는 인덱스 관련 부분이므로 덤프를 통해 데이터 손실 없이 복구가 가능하다

- 5(SRV_FORCE_NO_UNDO_LOG_SCAN)
    - 언두 로그를 모두 무시하고 MySQL 서버를 시작한다
    - 언두 로그가 손상되어 서버가 시작되지 못하는 경우에 사용한다
    - 서버가 종료되던 시점에 커밋되지 않은 작업도 모두 커밋된것처럼 처리되므로 실제로는 잘못된 데이터가 DB에 남는 것이다.

- 6(SRV_FORCE_NO_LOG_REDO)
    - 리두 로그를 모두 무시한 채 MySQL 서버를 시작한다
    - 리두 로그가 손상되어 서버가 시작되지 못하는 경우에 사용한다
    - 데이터 파일에 기록되지 않은 데이터는 모두 무시된 채 마지막 체크포인트 시점의 데이터만 남게 된다.